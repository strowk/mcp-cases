{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MCP Cases","text":""},{"location":"#format","title":"Format","text":"<p>The Model Context Protocol (MCP) is an open protocol that enables seamless integration between LLM applications and external data sources and tools. </p> <p>MCP is based on JSON-RPC 2.0 protocol with JSON objects sent from clients to servers and back. If you need to test server or mock it, it would be useful to describe input and output JSON objects as a separate cases.</p> <p>Since YAML is a superset of JSON, it is possible to define information as a stream of YAML documents.</p>"},{"location":"#example","title":"Example","text":"<p>Consider this example case of some simple MCP server:</p> <pre><code>case: List tools\n\n# when Client requests list of tools\nin: {\"jsonrpc\": \"2.0\", \"method\": \"tools/list\", \"id\": 1}\n\n# then Server gives one tool in the list\nout:\n  {\n    \"jsonrpc\": \"2.0\",\n    \"result\":\n      {\n        \"tools\":\n          [\n            {\n              \"description\": \"Lists files in the current directory\",\n              \"inputSchema\": { \"type\": \"object\" },\n              \"name\": \"list-current-dir-files\",\n            },\n          ],\n      },\n    \"id\": 1,\n  }\n</code></pre> <p>This file shows a test case as a document in YAML-formatted file. Case has one input and one output JSON objects following JSON-RPC 2.0 spec.</p> <p>Here is another example that replicates lifecycle described in the MCP specification, when you might need two inputs for one output:</p> <pre><code>case: Initialization lifecycle\n\n# Client requesting initialization\nin_request_to_initialize: {\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"initialize\",\n  \"params\": {\n    \"protocolVersion\": \"2024-11-05\",\n    \"capabilities\": {}, # made it emptier for brevity\n    \"clientInfo\": {\n      \"name\": \"ExampleClient\",\n      \"version\": \"1.0.0\"\n    }\n  }\n}\n\n# Server responding to initialization\nout: {\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": {\n    \"protocolVersion\": \"2024-11-05\",\n    \"capabilities\": {}, # made it emptier for brevity\n    \"serverInfo\": {\n      \"name\": \"ExampleServer\",\n      \"version\": \"1.0.0\"\n    }\n  }\n}\n\n# Clint notifies that initialization is done\nin_notification_initialized: {\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"notifications/initialized\"\n}\n\n---\n#  ... other cases ...\n</code></pre> <p>You might have noticed that both messages from client to server are starting from \"in\", while server again sends back \"out\". This is not a coincidence and in fact what this document is proposing - every key that starts with \"in\" indicates a request, response or notification sent from client to server, while \"out\" is a response or notification sent from server to client. For this protocol it is irrelevant whether the message is notification or not, as it is just a matter of the \"id\" field. \"in/out\" only indicate the expected direction of the communication.</p> <p>As YAML supports multiple documents in one file, it is possible to define multiple cases in one file, separated by <code>---</code> line.</p>"},{"location":"#formal","title":"Formal","text":"<p>MCP Cases is a multi-document YAML file called cases where each document describes a separate named case with lists of input and output JSON objects.</p> <p>The case document MAY have one <code>case</code> key mapped to string value, and it SHOULD be a human-readable name of the case and there MUST be only one such key in the case document.</p> <p>The case document MAY have one or multiple keys starting with <code>in</code>, each of them MUST map to a valid object that SHOULD be matching correct JSON-RPC 2.0 request, response or notification that is intended to be sent from client to server.</p> <p>The case document MAY have one or multiple keys starting with <code>out</code>, each of them MUST map to a valid object that SHOULD be matching correct JSON-RPC 2.0 request, response or notification that is intended to be sent from server to client.</p> <p>Note: When we say \"matching\", the meaning is that it is not necessary to represent that object as JSON, usual YAML can be used as well, but when parsed and printed as JSON, it SHOULD be valid JSON-RPC 2.0 object.</p> <p>For example such way of writing is also valid:</p> <pre><code>in:\n  jsonrpc: \"2.0\"\n  method: \"tools/list\"\n  id: 1\n  params: {}\n</code></pre> <p>, however writers of cases SHOULD be consistent and use the same style for all cases, and they SHOULD prefer to use JSON (quoted, objects and arrays in braces) style in favor of more generic YAML style for those objects, at the same time they MAY use YAML style for other parts of the document, such as root keys (<code>case</code>, <code>in</code>'s, <code>out</code>'s).</p> <p>That is everything regarding formal definition!</p>"},{"location":"#extensibility","title":"Extensibility","text":"<p>As this format is based around YAML and only reserves one keyword and two key prefixes, it is very easy to extend it with new features, such as for example including hooks for setup and teardown of the test cases, or including some metadata about the test cases that could be used for filtering or grouping them.</p> <p>MCP Cases format is considered a base for further development and is open for suggestions and improvements, that could be incorported based on what actual implementations would do.</p> <p>One convention, however would need to be established and that is that all root keys for extensions should be prefixed with <code>_</code> to avoid conflicts with future versions of this format.</p> <p>For example, if we would like to add a setup hook to the test case, we could do it like this:</p> <pre><code>case: List tools\n_before: { command: \"start-mcp-server\", arguments: [\"--port\", \"1234\"] }\n# ...\n</code></pre> <p>This ensures that anything that further versions of this format would add cannot be in conflict with any of implementations in the wild and such would ease the process of upgrading to newer versions of this specification.</p>"},{"location":"#motivation","title":"Motivation","text":""},{"location":"#contract-testing","title":"Contract Testing","text":"<p>Besids tests for MCP servers, this can be used it to create mock servers that you could use when checking client implementations.  The approach like that is known as <code>contract testing</code> and is a way to ensure that both client and server are working as expected, and that they are compatible with each other without actually running them together. You write list of cases that is a specification of things that you would like to make possible, and then you can run them against both client and server to see if they are compatible up to the point of those cases.  Such list of cases is then called a <code>contract</code>. Contracts then could be used to pass around between teams as a way of communication of what is expected and what has possibly gone wrong or got changed, etc.</p>"},{"location":"#rapid-prototyping","title":"Rapid Prototyping","text":"<p>When you only starting to develop your MCP server and not exactly sure how it should look like, you can start by writing MCP stories for the future implementation, while you collect requirements from experts and stakeholders. Having such active document could be a great way to communicate between people with different competences and to ensure that everyone is on the same page, while at the same time giving you a way to test your implementation later as well as seeing how LLMs would interact with it before you even start building.</p> <p>Same applies for any new features you would be implementing. Not sure if it is better to be a prompt or a tool? Sketch a quick case, give it to mock server and see how it would look like from the actual client's perspective.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>This format can be used to generate documentation for MCP servers to be published on the web.</p>"},{"location":"implementations/","title":"Known Implementations","text":"<p>These implementations are following MCP Cases format at the moment:</p> <ul> <li>foxytest - Golang package implmenting integration tests for MCP servers, which is a part of foxy-contexts library</li> </ul> <p>If you make anything based on this specification, please let me know so it can be listed here!</p> Name Description License foxytest Golang package for MCP server integration tests MIT"},{"location":"implementations/#foxytest","title":"foxytest","text":"<p>foxytest is a Golang package for MCP server integration tests.</p> <p>You can use this package without foxy-contexts library and even mostly without knowing Golang, as you would only ever need one 20 lines long <code>*_test.go</code> file, that looks like this:</p> <pre><code>package main\n\nimport (\n    \"testing\"\n\n    \"github.com/strowk/foxy-contexts/pkg/foxytest\"\n)\n\nfunc TestServer(t *testing.T) {\n    ts, err := foxytest.Read(\"testdata\")\n    if err != nil {\n        t.Fatal(err)\n    }\n    ts.WithExecutable(\"go\", []string{\"run\", \"main.go\"})\n    ts.Run(t)\n    ts.AssertNoErrors(t)\n}\n</code></pre> <p>This script reads test cases defined in format described above from \"testdata\" folder as a files with <code>_test.yaml</code> suffix, and runs them against <code>my_installed_mcp_server</code> executable, that would be started with no arguments.</p> <p>To run this, you would still need to install Golang and use <code>go test</code> command running it in the same folder as the <code>*_test.go</code> file (f.e name it <code>main_test.go</code>).</p>"},{"location":"links/","title":"Links","text":""}]}